# frozen_string_literal: true

module Rundoc
  # A code secttion respesents a block of fenced code
  #
  # A document can have multiple code sections
  class CodeSection
    class ParseError < StandardError
      def initialize(options = {})
        keyword = options[:keyword]
        command = options[:command]
        line_number = options[:line_number]
        block = options[:block].lines.map do |line|
          if line == command
            "    > #{line}"
          else
            "      #{line}"
          end
        end.join("")

        msg = "Error parsing (line:#{line_number}):\n"
        msg << ">  '#{command.strip}'\n"
        msg << "No such registered command: '#{keyword}'\n"
        msg << "registered commands: #{Rundoc.known_commands.inspect}\n\n"
        msg << block
        msg << "\n"
        super(msg)
      end
    end

    COMMAND_REGEX = Rundoc::Parser::COMMAND_REGEX # todo: move whole thing
    AUTOGEN_WARNING = "\n<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->"
    attr_accessor :original, :fence, :lang, :code, :keyword

    PARTIAL_RESULT = []
    PARTIAL_ENV = {}

    def executed_commands
      raise "Nothing executed" unless @env[:commands].any?

      @env[:commands].map { |c| c[:object] }
    end

    def initialize(match, keyword:, context:)
      @original = match.to_s
      @env = {}
      @stack = []
      @keyword = keyword
      @context = context
      @fence = match[:fence]
      @lang = match[:lang]
      @code = match[:contents]
      self.class.parse_code_commands(@code).each do |code_command|
        @stack << code_command
      end

      PARTIAL_RESULT.clear
      PARTIAL_ENV.clear
    end

    def render
      result = []
      env = @env
      env[:commands] = []
      env[:fence_start] = "#{fence}#{lang}"
      env[:fence_end] = "#{fence}#{AUTOGEN_WARNING}"
      env[:before] = []
      env[:after] = []
      env[:context] = @context

      @stack.each do |s|
        code_command = s
        code_output = code_command.call(env) || ""
        code_line = code_command.to_md(env) || ""

        env[:commands] << {
          object: code_command,
          output: code_output,
          command: code_line
        }

        tmp_result = []
        tmp_result << code_line if code_command.render_command?
        tmp_result << code_output if code_command.render_result?

        result << tmp_result unless code_command.hidden?

        PARTIAL_RESULT.replace(result)
        PARTIAL_ENV.replace(env)
      end

      return "" if env[:commands].all? { |c| c[:object].hidden? }

      self.class.to_doc(result: result, env: env)
    end

    def self.partial_result_to_doc
      to_doc(result: PARTIAL_RESULT, env: PARTIAL_ENV)
    end

    def self.to_doc(result:, env:)
      array = [env[:before]]

      result.flatten!
      result.compact!
      result.map! { |s| s.respond_to?(:rstrip) ? s.rstrip : s }
      result.reject!(&:empty?)
      result.map!(&:to_s)

      if !result.empty?
        array << env[:fence_start]
        array << result
        array << env[:fence_end]
      end
      array << env[:after]

      array.flatten!
      array.compact!
      array.map! { |s| s.respond_to?(:rstrip) ? s.rstrip : s }
      array.reject!(&:empty?)
      array.map!(&:to_s)

      array.join("\n") << "\n"
    end

    def self.parse_code_commands(code)
      parser = Rundoc::PegParser.new.code_block
      tree = parser.parse(code)
      commands = Rundoc::PegTransformer.new.apply(tree)
      commands = [commands] unless commands.is_a?(Array)
      commands
    rescue ::Parslet::ParseFailed => e
      raise "Could not compile code:\n#{code}\nReason: #{e.message}"
    end
  end
end
